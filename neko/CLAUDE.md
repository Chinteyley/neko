<!-- AUTO-MANAGED: project-description -->
# Neko.app

A macOS desktop pet application - a tiny kitten sprite that follows the mouse cursor across the screen. Uses SwiftUI and AppKit for a borderless, transparent overlay window.
<!-- END AUTO-MANAGED -->

<!-- AUTO-MANAGED: architecture -->
## Architecture

### Core Components

- `main.swift` - Application entry point (macOS 26 compatibility, replaces @main attribute)
- `AppDelegate.swift` - Window setup, animation timer, pause/resume lifecycle management
- `Store.swift` - State management and animation logic (60fps tick loop)
- `ContentView.swift` - SwiftUI view wrapping NekoAnimation
- `NekoAnimation.swift` - Animation frame selector
- `Neko.swift` - Sprite rendering component
- `Settings.swift` - User preferences (size, speed, idle animations, enabled state)
- `StatusBarController.swift` - Menu bar UI for settings

### Window Configuration

- Borderless, transparent window at `mainMenu` level
- Joins all spaces (`canJoinAllSpaces`, `fullScreenAuxiliary`)
- Ignores all mouse events (clickthrough)
- Fixed 16x16 base size (scales with settings)

### Lifecycle Management

- Animation timer managed by `AppDelegate` (can be paused/resumed)
- `pauseNeko()` - Invalidates timer and hides window via `orderOut(nil)`
- `resumeNeko()` - Shows window and restarts animation timer
- `restartAnimationTimer()` - Used when speed setting changes
- Timer interval determined by `Settings.shared.currentSpeed.rawValue`
<!-- END AUTO-MANAGED -->

<!-- AUTO-MANAGED: conventions -->
## Conventions

### Application Entry Point

- Use explicit `main.swift` with manual app initialization (not `@main` attribute)
- Required for macOS 26 compatibility

### State Management

- `Store` is `ObservableObject` with `@Published` properties
- Timer runs at 0.16s interval (60fps) calling `store.nextTick()`
- Direction and animation state updated each tick

### Settings Architecture

- Singleton `Settings.shared` with `@Published` properties
- UserDefaults persistence for size, speed, idle animations, enabled state
- Settings keys: `nekoSize`, `nekoSpeed`, `nekoIdleAnimations`, `nekoEnabled`
- Combine publishers for reactive menu updates

### Window Setup Order

1. Create window with borderless style
2. Configure level and collection behavior
3. Initialize Store with initial positions
4. Set up ContentView and NSHostingView
5. Start animation timer
6. Configure transparency (backgroundColor with alpha 0)
7. Set ignoresMouseEvents for click-through behavior
8. Show window

**Critical**: `ignoresMouseEvents` must be set AFTER `backgroundColor` to ensure proper click-through functionality
<!-- END AUTO-MANAGED -->

<!-- AUTO-MANAGED: patterns -->
## Patterns

### Animation State Machine

- Enum-based direction tracking (`Direction`: none, northWest, north, etc.)
- Animation arrays cycled by tick count
- Idle animations triggered by `ticksSinceLastMove` counter
- State transitions: alert → moving → idle → grooming → yawning → sleeping

### SwiftUI + AppKit Integration

- `NSHostingView` wraps SwiftUI `ContentView`
- Bindings connect Store state to view updates
- Timer updates run on main queue with `DispatchQueue.main.async`

### Settings Observation

- `StatusBarController` subscribes to Settings publishers
- Menu checkmarks update automatically via Combine
- Callbacks trigger external changes (e.g., timer speed adjustment)

### Callback Pattern (StatusBarController ↔ AppDelegate)

- `onSpeedChange` callback - Triggers `restartAnimationTimer()` when speed changes
- `onToggleEnabled` callback - Triggers `pauseNeko()` or `resumeNeko()` based on `Settings.shared.nekoEnabled`
- Menu items dynamically update titles (e.g., "Pause Neko" ↔ "Resume Neko")
<!-- END AUTO-MANAGED -->

<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>